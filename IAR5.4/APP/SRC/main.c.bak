/*****************************Copyright (c)**********************************
**--------------File Info----------------------------------------------------
** File name:			    Main.c
** Created by:		    Alex Hsu
** Created date:		  2009-25-06
**
******************************************************************************
------------------------------Vervision---------------------------------------
**
*******************************************************************************/
/* Includes ------------------------------------------------------------------*/
#include "stm32f10x.h"
#include "hw_config.h"
#include "Delay.h"
#include "USART.h"
#include "ADC_Sample.h"
#include "fpga.h"

unsigned char Com_Buf[6] = {0xFF,0x00,0x00,0x00,0x00,0x00};	
unsigned char com_buffer_cnt;  //存储时计数
unsigned char State_Flag; //硬件状态REG

extern volatile unsigned int ADC_DualConvertedValueTab[32];
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/


/*******************************************************************************
* Function Name  : main
* Description    :  
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/




int main(void)
{
  /* Add your application code here
     */
  int i=0;
  int j=0;
  //u8 tab[42];
  
  HW_SetSystem();  //硬件配置
  sys_init();
  

  /* Infinite loop */
  while (1)
  {
    
   // FPGA_TEST_REG=0x5555;
  //  FPGA_AFEBOARD_HORIZON_NUM=0x55;
    Delay_NS(10);
   // FPGA_TEST_REG=0xaaaa;
  //  FPGA_AFEBOARD_HORIZON_NUM=0xaa;
    Delay_NS(10);
    
    //1、串口命令处理
  	//串口命令解释,这里要加一个timer，如果接收到至少一个字符后启动，如果timeout了，还没有收到6个char，
  	//则表示串口通信有错，要复位buffer,等待接收下一个命令
  	
  	if(com_buffer_cnt == 5) //buffer full
  	{
  	  COM_Process();
  	  com_buffer_cnt=0;  //reset
  	}
  	else if(com_buffer_cnt > 0) //收到数了
  	{
  		//启动timer计数
  		i++;
  		
  		if(i=65000) //timeout
  		{
  			com_buffer_cnt=0; //复位
  		}
  	}
  	else
  	{
  		i=0;
  	}
    
    //2、USB命令处理
    
    
    //3、系统状态检测
    
  }
}



void sys_init(void)
{
  
  FPGA_FSMCConfig();
  
  ADC_Config();
  
  UART_Init();
  
  //beep
  BUZZER; Delay_MS(200); BUZZER;Delay_MS(200);BUZZER ;
  
  SYS_RESET;
  
  FPGA_AFEBOARD_HORIZON_NUM=512;
  
  FPGA_AFEBOARD_VERTICAL_NUM=512;
  
  FPGA_AFEBOARD_TOTALPIXEL_NUM=2048;
  
  FPGA_INTG_TIME_REG= 140;
  
  FPGA_AFEBOARD_SCANPIXEL_NUM=980;
  
  FPGA_ADC_CTRL_REG=0x0001;             // scan start
  
}




#ifdef  USE_FULL_ASSERT
/*******************************************************************************
* Function Name  : assert_failed
* Description    : Reports the name of the source file and the source line number
*                  where the assert_param error has occurred.
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void assert_failed(uint8_t* file, uint32_t line)
{ 
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {
  	

  	
  }
}
#endif


//0xFA, //查询
//0xF8, // 电机及光障命令
//0xF7, //射线灯及报警灯命令
//0xF1, //自检命令（复位命令
//0xF2, //关机命令（往返同
//0xF3:  //系统复位命令，复位硬件系统
void COM_Process(void)
{
	unsigned char Flag[4];
	
	switch(Com_Buf[0]) //命令头
	{
		case 0xFA:  //查询命令
			   
			   Flag[0] = (State_Flag & 0x03);
			   GZ_IN1_MCU = 1;
			   GZ_IN2_MCU = 1;
			   GZ_IN1_STU = GZ_IN1_MCU;
			   GZ_IN2_STU = GZ_IN2_MCU;
			   Flag[1] = (State_Flag & 0x3C);
			   Flag[1] = Flag[1] >>2;
			   Flag[2] = (State_Flag & 0xC0);
			   Flag[2] = Flag[2] >>6;
			   if(Chk_Flag != 0x00)
			   {
			   	 Flag[2] = (Flag[2] | 0x10);
			   }
         
			   Flag[3] = 0xFA^Flag[0];
			   Flag[3] = Flag[3]^Flag[1];
			   Flag[3] = Flag[3]^Flag[2];
			   Flag[3] = Flag[3]&0x7F;
         
			   Send(0xFA);
			   Send(Flag[0]);
			   Send(Flag[1]);
			   Send(Flag[2]);
			   Send(Flag[3]);
			   Send(0xFF);
			   
		     break;
		case 0xF8:  //电机及光障命令
		
			   if((Com_Buf[1]&0x03) == 0)			
			   {
			   	 Motor_Control(MOTOR_STOP);
			   	 Flag[0] = 0x00;	
			   }
			   else if((Com_Buf[1]&0x03) == 0x01)	
			   {
			   	 Motor_Control(MOTOR_FWD);
			   	 Flag[0] = 0x01;		
			   }
			   else if((Com_Buf[1]&0x03) == 0x02)
			   {
			   	 Motor_Control(MOTOR_BACK);
			   	 Flag[0] = 0x02;
			   }
         
			   if((Com_Buf[2]&0x03) == 0x00)
			   {
			   	 Close_GZ1;
			   	 Close_GZ2;
			   	 Flag[1] = 0x00;
			   }
			   else if((Com_Buf[2]&0x03) == 0x01)
			   {
			   	 Open_GZ1;
			   	 Close_GZ2;
			   	 Flag[1] = 0x01;		
			   }
			   else if((Com_Buf[2]&0x03) == 0x02)		
			   {
			   	 Close_GZ1;
			   	 Open_GZ2;
			   	 Flag[1] = 0x02;		
			   }
         
			   Flag[2] = 0x00;	
			   Flag[3] = 0xF8^Flag[0];	
			   Flag[3] = Flag[3]^Flag[1];	
			   Flag[3] = Flag[3]^Flag[2];	
			   Flag[3] = Flag[3]&0x7F;		
         
			   Send(0xF8);
			   Send(Flag[0]);
			   Send(Flag[1]);
			   Send(Flag[2]);
			   Send(Flag[3]);
			   Send(0xFF);
			   
		     break;
		case 0xF7:  //射线灯及报警灯命令
      
			   if(((Com_Buf[1]&0x03) == 0x00) || ((Com_Buf[1]&0x03) == 0x02))
			   {
			   	 Flag[0] = XRAY_LED_STU;
			   }
			   else if((Com_Buf[1]&0x03) == 0x01)
			   {
			   	 Close_XRAY_LED;
			     Flag[0] = 0x00;
			   }
			   else if((Com_Buf[1]&0x03) == 0x03)
			   {
			   	 Open_XRAY_LED;
			   	 Flag[0] = 0x01;
			   }
         
         
			   if(((Com_Buf[2]&0x03) == 0x00) || ((Com_Buf[2]&0x03) == 0x02))
			   {
			   	 Flag[1] = WARN_LED_STU;
			   }
			   else if((Com_Buf[2]&0x03) == 0x01)
			   {
			   	 Close_WARN_LED;
			   	 Flag[1] = 0x00;
			   }
			   else if((Com_Buf[2]&0x03) == 0x03)
			   {
			   	 Open_WARN_LED;
			   	 Flag[1] = 0x01;
			   }
         
			   Flag[2] = 0x00;
         
			   Flag[3] = 0xF7^Flag[0];
			   Flag[3] = Flag[3]^Flag[1];
			   Flag[3] = Flag[3]^Flag[2];
			   Flag[3] = Flag[3]&0x7F;
         
			   Send(0xF7);
			   Send(Flag[0]);
			   Send(Flag[1]);
			   Send(Flag[2]);
			   Send(Flag[3]);
			   Send(0xFF);
		     
		     break;
		case 0xF1:   //自检命令（复位命令
			   Self_Check();
         
			   Flag[0] = 0x00;		
			   Flag[1] = Chk_Flag; 
			   Flag[2] = 0x00;		
         
			   Flag[3] = 0xF1^Flag[0];	
			   Flag[3] = Flag[3]^Flag[1];	
			   Flag[3] = Flag[3]^Flag[2];	
			   Flag[3] = Flag[3]&0x7F;		
         
			   Send(0xF1);
			   Send(Flag[0]);
			   Send(Flag[1]);
			   Send(Flag[2]);
			   Send(Flag[3]);
			   Send(0xFF);
		     
		     break;
		case 0xF2:  //关机命令（往返同
			   if( (Com_Buf[1]==0x00) && (Com_Buf[2]==0x00) && (Com_Buf[3]==0x00)&& (Com_Buf[4]==0x72) )
			   {
			   	 Delay_s(50);
			   	 Power_Cutoff;
			   	 Delay_ms(100);
			   }
         
		     break;
		case 0xF3:  //系统复位命令
			   if( (Com_Buf[1]==0x01) && (Com_Buf[2]==0x02) && (Com_Buf[3]==0x03)&& (Com_Buf[4]==0x72))
			   {
			   	 System_nRST_CTRL = 1;
			   	 DAQ_nRST_CTRL = 0;
			   	 Delay_ms(200);	
			   	 System_nRST_CTRL = 0;
			   	 DAQ_nRST_CTRL = 1;
			   	 Send(0xF3);
			   	 Send(0x01);
			   	 Send(0x02);
			   	 Send(0x03);
			   	 Send(0x72);
			   	 Send(0xFF);
			   }
			   
		     break;
		default:  //error
			   Send(0xFF);
			   Send(0xFF);
			   Send(0xFF);
			   Send(0xFF);
			   Send(0xFF);
			   Send(0xFF);
			   
		     break;
	}
	Com_Buf[0]=0xFF;
}


void Motor_Control(uchar Flag)
{

	if(Flag == MOTOR_STOP)
	{
		//P3=P3&0xCF;		
		MOT_BACK_MCU = 0;
		//MOT_FWD_MCU  = 0;
		//Delay_ms(250);
		MOT_FWD_MCU  = 0;
		//MOT_BACK_MCU = 0;
		MOTOR_STU2 = 0;	 
		MOTOR_STU1 = 0;	 
		Delay_ms(100);
		//Delay_s(1);
		return ;
	}
	if(Flag == MOTOR_FWD)
	{
		//MOT_BACK_MCU = 0;
		//MOT_FWD_MCU  = 0;
		MOT_BACK_MCU = 0;
		Delay_ms(500);
		//Delay_s(1);
		MOT_FWD_MCU  = 1;
		
		
		MOTOR_STU2 = 0;	 
		MOTOR_STU1 = 1;  
		Delay_ms(100);
		return;
	}
	if(Flag == MOTOR_BACK)
	{
		//MOT_BACK_MCU = 0;
		//MOT_FWD_MCU  = 0;
		
		MOT_FWD_MCU  = 0;
		Delay_ms(500);
		//Delay_s(1);
		//MOT_BACK_MCU = 1;
		MOT_BACK_MCU = 1;
		Delay_ms(500);
		MOT_FWD_MCU  = 1;
		MOTOR_STU2 = 1;	 
		MOTOR_STU1 = 1;  
		Delay_ms(100);
		return ;	
	}
}


/******************* (C) COPYRIGHT 2009 MYTech *****END OF FILE****/
